/// Generated by the Protocol Buffers 3.3.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.21
/// Source file "controller.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct ControllerRoot {
    public static let `default` = ControllerRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class ControllerData : GeneratedMessage {
    public typealias BuilderType = ControllerData.Builder

    public static func == (lhs: ControllerData, rhs: ControllerData) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasMA == rhs.hasMA) && (!lhs.hasMA || lhs.mA == rhs.mA)
        fieldCheck = fieldCheck && (lhs.hasUId == rhs.hasUId) && (!lhs.hasUId || lhs.uId == rhs.uId)
        fieldCheck = fieldCheck && (lhs.hasOId == rhs.hasOId) && (!lhs.hasOId || lhs.oId == rhs.oId)
        fieldCheck = fieldCheck && (lhs.hasSId == rhs.hasSId) && (!lhs.hasSId || lhs.sId == rhs.sId)
        fieldCheck = fieldCheck && (lhs.hasCfm == rhs.hasCfm) && (!lhs.hasCfm || lhs.cfm == rhs.cfm)
        fieldCheck = fieldCheck && (lhs.hasLpm == rhs.hasLpm) && (!lhs.hasLpm || lhs.lpm == rhs.lpm)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var mA:String! = nil
    public fileprivate(set) var hasMA:Bool = false

    public fileprivate(set) var uId:String! = nil
    public fileprivate(set) var hasUId:Bool = false

    public fileprivate(set) var oId:String! = nil
    public fileprivate(set) var hasOId:Bool = false

    public fileprivate(set) var sId:String! = nil
    public fileprivate(set) var hasSId:Bool = false

    public fileprivate(set) var cfm:Float! = nil
    public fileprivate(set) var hasCfm:Bool = false

    public fileprivate(set) var lpm:Int32! = nil
    public fileprivate(set) var hasLpm:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasMA {
            try codedOutputStream.writeString(fieldNumber: 1, value:mA)
        }
        if hasUId {
            try codedOutputStream.writeString(fieldNumber: 2, value:uId)
        }
        if hasOId {
            try codedOutputStream.writeString(fieldNumber: 3, value:oId)
        }
        if hasSId {
            try codedOutputStream.writeString(fieldNumber: 4, value:sId)
        }
        if hasCfm {
            try codedOutputStream.writeFloat(fieldNumber: 5, value:cfm)
        }
        if hasLpm {
            try codedOutputStream.writeInt32(fieldNumber: 6, value:lpm)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasMA {
            serialize_size += mA.computeStringSize(fieldNumber: 1)
        }
        if hasUId {
            serialize_size += uId.computeStringSize(fieldNumber: 2)
        }
        if hasOId {
            serialize_size += oId.computeStringSize(fieldNumber: 3)
        }
        if hasSId {
            serialize_size += sId.computeStringSize(fieldNumber: 4)
        }
        if hasCfm {
            serialize_size += cfm.computeFloatSize(fieldNumber: 5)
        }
        if hasLpm {
            serialize_size += lpm.computeInt32Size(fieldNumber: 6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ControllerData.Builder {
        return ControllerData.classBuilder() as! ControllerData.Builder
    }
    public func getBuilder() -> ControllerData.Builder {
        return classBuilder() as! ControllerData.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ControllerData.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ControllerData.Builder()
    }
    public func toBuilder() throws -> ControllerData.Builder {
        return try ControllerData.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ControllerData) throws -> ControllerData.Builder {
        return try ControllerData.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasMA {
            jsonMap["mA"] = mA
        }
        if hasUId {
            jsonMap["uID"] = uId
        }
        if hasOId {
            jsonMap["oID"] = oId
        }
        if hasSId {
            jsonMap["sID"] = sId
        }
        if hasCfm {
            jsonMap["cfm"] = Float(cfm)
        }
        if hasLpm {
            jsonMap["lpm"] = Int(lpm)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ControllerData {
        return try ControllerData.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ControllerData {
        return try ControllerData.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasMA {
            output += "\(indent) mA: \(mA) \n"
        }
        if hasUId {
            output += "\(indent) uId: \(uId) \n"
        }
        if hasOId {
            output += "\(indent) oId: \(oId) \n"
        }
        if hasSId {
            output += "\(indent) sId: \(sId) \n"
        }
        if hasCfm {
            output += "\(indent) cfm: \(cfm) \n"
        }
        if hasLpm {
            output += "\(indent) lpm: \(lpm) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMA {
                hashCode = (hashCode &* 31) &+ mA.hashValue
            }
            if hasUId {
                hashCode = (hashCode &* 31) &+ uId.hashValue
            }
            if hasOId {
                hashCode = (hashCode &* 31) &+ oId.hashValue
            }
            if hasSId {
                hashCode = (hashCode &* 31) &+ sId.hashValue
            }
            if hasCfm {
                hashCode = (hashCode &* 31) &+ cfm.hashValue
            }
            if hasLpm {
                hashCode = (hashCode &* 31) &+ lpm.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ControllerData"
    }
    override public func className() -> String {
        return "ControllerData"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ControllerData = ControllerData()
        public func getMessage() -> ControllerData {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var mA:String {
            get {
                return builderResult.mA
            }
            set (value) {
                builderResult.hasMA = true
                builderResult.mA = value
            }
        }
        public var hasMA:Bool {
            get {
                return builderResult.hasMA
            }
        }
        @discardableResult
        public func setMA(_ value:String) -> ControllerData.Builder {
            self.mA = value
            return self
        }
        @discardableResult
        public func clearMA() -> ControllerData.Builder{
            builderResult.hasMA = false
            builderResult.mA = nil
            return self
        }
        public var uId:String {
            get {
                return builderResult.uId
            }
            set (value) {
                builderResult.hasUId = true
                builderResult.uId = value
            }
        }
        public var hasUId:Bool {
            get {
                return builderResult.hasUId
            }
        }
        @discardableResult
        public func setUId(_ value:String) -> ControllerData.Builder {
            self.uId = value
            return self
        }
        @discardableResult
        public func clearUId() -> ControllerData.Builder{
            builderResult.hasUId = false
            builderResult.uId = nil
            return self
        }
        public var oId:String {
            get {
                return builderResult.oId
            }
            set (value) {
                builderResult.hasOId = true
                builderResult.oId = value
            }
        }
        public var hasOId:Bool {
            get {
                return builderResult.hasOId
            }
        }
        @discardableResult
        public func setOId(_ value:String) -> ControllerData.Builder {
            self.oId = value
            return self
        }
        @discardableResult
        public func clearOId() -> ControllerData.Builder{
            builderResult.hasOId = false
            builderResult.oId = nil
            return self
        }
        public var sId:String {
            get {
                return builderResult.sId
            }
            set (value) {
                builderResult.hasSId = true
                builderResult.sId = value
            }
        }
        public var hasSId:Bool {
            get {
                return builderResult.hasSId
            }
        }
        @discardableResult
        public func setSId(_ value:String) -> ControllerData.Builder {
            self.sId = value
            return self
        }
        @discardableResult
        public func clearSId() -> ControllerData.Builder{
            builderResult.hasSId = false
            builderResult.sId = nil
            return self
        }
        public var cfm:Float {
            get {
                return builderResult.cfm
            }
            set (value) {
                builderResult.hasCfm = true
                builderResult.cfm = value
            }
        }
        public var hasCfm:Bool {
            get {
                return builderResult.hasCfm
            }
        }
        @discardableResult
        public func setCfm(_ value:Float) -> ControllerData.Builder {
            self.cfm = value
            return self
        }
        @discardableResult
        public func clearCfm() -> ControllerData.Builder{
            builderResult.hasCfm = false
            builderResult.cfm = nil
            return self
        }
        public var lpm:Int32 {
            get {
                return builderResult.lpm
            }
            set (value) {
                builderResult.hasLpm = true
                builderResult.lpm = value
            }
        }
        public var hasLpm:Bool {
            get {
                return builderResult.hasLpm
            }
        }
        @discardableResult
        public func setLpm(_ value:Int32) -> ControllerData.Builder {
            self.lpm = value
            return self
        }
        @discardableResult
        public func clearLpm() -> ControllerData.Builder{
            builderResult.hasLpm = false
            builderResult.lpm = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ControllerData.Builder {
            builderResult = ControllerData()
            return self
        }
        override public func clone() throws -> ControllerData.Builder {
            return try ControllerData.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ControllerData {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ControllerData {
            let returnMe:ControllerData = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ControllerData) throws -> ControllerData.Builder {
            if other == ControllerData() {
                return self
            }
            if other.hasMA {
                mA = other.mA
            }
            if other.hasUId {
                uId = other.uId
            }
            if other.hasOId {
                oId = other.oId
            }
            if other.hasSId {
                sId = other.sId
            }
            if other.hasCfm {
                cfm = other.cfm
            }
            if other.hasLpm {
                lpm = other.lpm
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ControllerData.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerData.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    mA = try codedInputStream.readString()

                case 18:
                    uId = try codedInputStream.readString()

                case 26:
                    oId = try codedInputStream.readString()

                case 34:
                    sId = try codedInputStream.readString()

                case 45:
                    cfm = try codedInputStream.readFloat()

                case 48:
                    lpm = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ControllerData.Builder {
            let resultDecodedBuilder = ControllerData.Builder()
            if let jsonValueMA = jsonMap["mA"] as? String {
                resultDecodedBuilder.mA = jsonValueMA
            }
            if let jsonValueUId = jsonMap["uID"] as? String {
                resultDecodedBuilder.uId = jsonValueUId
            }
            if let jsonValueOId = jsonMap["oID"] as? String {
                resultDecodedBuilder.oId = jsonValueOId
            }
            if let jsonValueSId = jsonMap["sID"] as? String {
                resultDecodedBuilder.sId = jsonValueSId
            }
            if let jsonValueCfm = jsonMap["cfm"] as? Float {
                resultDecodedBuilder.cfm = Float(jsonValueCfm)
            } else if let jsonValueCfm = jsonMap["cfm"] as? String {
                resultDecodedBuilder.cfm = Float(jsonValueCfm)!
            }
            if let jsonValueLpm = jsonMap["lpm"] as? Int {
                resultDecodedBuilder.lpm = Int32(jsonValueLpm)
            } else if let jsonValueLpm = jsonMap["lpm"] as? String {
                resultDecodedBuilder.lpm = Int32(jsonValueLpm)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ControllerData.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ControllerData.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ControllerDelete : GeneratedMessage {
    public typealias BuilderType = ControllerDelete.Builder

    public static func == (lhs: ControllerDelete, rhs: ControllerDelete) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasCmd == rhs.hasCmd) && (!lhs.hasCmd || lhs.cmd == rhs.cmd)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var cmd:String! = nil
    public fileprivate(set) var hasCmd:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasCmd {
            try codedOutputStream.writeString(fieldNumber: 1, value:cmd)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasCmd {
            serialize_size += cmd.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ControllerDelete.Builder {
        return ControllerDelete.classBuilder() as! ControllerDelete.Builder
    }
    public func getBuilder() -> ControllerDelete.Builder {
        return classBuilder() as! ControllerDelete.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ControllerDelete.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ControllerDelete.Builder()
    }
    public func toBuilder() throws -> ControllerDelete.Builder {
        return try ControllerDelete.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ControllerDelete) throws -> ControllerDelete.Builder {
        return try ControllerDelete.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasCmd {
            jsonMap["cmd"] = cmd
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ControllerDelete {
        return try ControllerDelete.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ControllerDelete {
        return try ControllerDelete.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasCmd {
            output += "\(indent) cmd: \(cmd) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCmd {
                hashCode = (hashCode &* 31) &+ cmd.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ControllerDelete"
    }
    override public func className() -> String {
        return "ControllerDelete"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ControllerDelete = ControllerDelete()
        public func getMessage() -> ControllerDelete {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var cmd:String {
            get {
                return builderResult.cmd
            }
            set (value) {
                builderResult.hasCmd = true
                builderResult.cmd = value
            }
        }
        public var hasCmd:Bool {
            get {
                return builderResult.hasCmd
            }
        }
        @discardableResult
        public func setCmd(_ value:String) -> ControllerDelete.Builder {
            self.cmd = value
            return self
        }
        @discardableResult
        public func clearCmd() -> ControllerDelete.Builder{
            builderResult.hasCmd = false
            builderResult.cmd = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ControllerDelete.Builder {
            builderResult = ControllerDelete()
            return self
        }
        override public func clone() throws -> ControllerDelete.Builder {
            return try ControllerDelete.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ControllerDelete {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ControllerDelete {
            let returnMe:ControllerDelete = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ControllerDelete) throws -> ControllerDelete.Builder {
            if other == ControllerDelete() {
                return self
            }
            if other.hasCmd {
                cmd = other.cmd
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ControllerDelete.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerDelete.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    cmd = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ControllerDelete.Builder {
            let resultDecodedBuilder = ControllerDelete.Builder()
            if let jsonValueCmd = jsonMap["cmd"] as? String {
                resultDecodedBuilder.cmd = jsonValueCmd
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ControllerDelete.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ControllerDelete.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension ControllerData: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ControllerData> {
        var mergedArray = Array<ControllerData>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ControllerData? {
        return try ControllerData.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(data: data, extensionRegistry:ControllerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerData {
        return try ControllerData.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "mA": return self.mA
        case "uId": return self.uId
        case "oId": return self.oId
        case "sId": return self.sId
        case "cfm": return self.cfm
        case "lpm": return self.lpm
        default: return nil
        }
    }
}
extension ControllerData.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ControllerData
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "mA": return self.mA
            case "uId": return self.uId
            case "oId": return self.oId
            case "sId": return self.sId
            case "cfm": return self.cfm
            case "lpm": return self.lpm
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "mA":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.mA = newSubscriptValue
            case "uId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.uId = newSubscriptValue
            case "oId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.oId = newSubscriptValue
            case "sId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sId = newSubscriptValue
            case "cfm":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.cfm = newSubscriptValue
            case "lpm":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.lpm = newSubscriptValue
            default: return
            }
        }
    }
}
extension ControllerDelete: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ControllerDelete> {
        var mergedArray = Array<ControllerDelete>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ControllerDelete? {
        return try ControllerDelete.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(data: data, extensionRegistry:ControllerRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControllerDelete {
        return try ControllerDelete.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cmd": return self.cmd
        default: return nil
        }
    }
}
extension ControllerDelete.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ControllerDelete
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cmd": return self.cmd
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cmd":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cmd = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
